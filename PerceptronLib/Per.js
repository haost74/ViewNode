const X = 2, N = [5, 3, 1], Xn = 20, Yn = 10, P = 2, left = 0, right = 1;
var L = N.length, w = [], S = [], out = [], Ts = [], Er = [['Итерация', 'Ошибка']], iteration = 0;
function rnd(min, max) //Функция случайного числа в диапазоне min - max
{
    return (min + Math.random() * (max - min));
}
function initialization()   //Функция инициализации весовых коэффициентов нейронной сети////////////////////////////////
{                             //
    w = [];                       // обнуление массива
    N.forEach(                      //Цикл по массиву слоев НС (в каждой ячейке массива количество нейронов в слое)
        (value, index) =>      //value - значение перебераемой ячейки в массиве N, index - номер ячейки массива
        {                       //
            w.push([]);             //Добавление нового пустого слоя 
            for (var i = 0; i < value; i++) //Цикл для каждого слоя, предназначен чтобы создать нейроны, каждая итерация - это описание нейрона в слое 
            {                           //
                w[index].push([]);          // Добавление нового нейрона в слой
                var n = index > 0 ? N[index - 1] : X; //Определение количество весов на нейроне по количеству входов в него из предыдущего слоя
                for (var j = 0; j < n; j++)              // Цикл для создания весовых коэфициентов, число n отражает количество весов в нейроне
                {                                       //
                    w[index][i].push(rnd(-0.5, 0.5));    //  Добавление нового весового коэффициента в нейрон
                }                                           //
            }                                               //
        }                                                   //
    )                                                        //
}                                                                     //////////////////////////////////////////////////////////////////////////////////        

function neuron(x)  //Функция нейронной сети///////////////////////////////////////////////////////////
{                     //
    S = [];                 // Обнуление массива сумматоров сети
    out = [];                 //Обнуление функций активации сети
    N.forEach(                //Цикл по каждому слою сети
        (layer, l) =>             //layer - значение перебераемой ячейки в массиве N, l - номер ячейки массива
        {                           //
            S.push([]);                 //  Добавление нового слоя в массив сумматоров
            out.push([]);                 //  Добавление нового слоя в массив функций активации
            S[l] = Array(layer).fill(0);      // Обнуление сумматоров нейронов в слое
            out[l] = Array(layer).fill(0);      // Обнуление функций активации нейронов в слое
            w[l].forEach(                       // Цикл перебирающий каждый нерон в слое
                (k, j) =>                           //k - массив весовых коэффициентов нейрона, j - индекс нейрона в слое
                {                                     //
                    ((l > 0) ? out[l - 1] : x).forEach(           //Перебор входных воздействий в зависимости от номера слоя
                        (value, i) =>                //value - входное значение в нейрон, i - номер входного значения 
                        {
                            S[l][j] += (value * w[l][j][i]); // Суммирование произведений входных значений на весовые коэффициенты
                        }                                    //         
                    );                                                   //
                    out[l][j] = 1 / (1 + Math.exp(-0.3 * S[l][j]));               //  Расчет функции активации нейрона
                }                                                         //
            )                                                             //
        }                                                                 //
    )                                                                     //
    return out[L - 1][0];                                                     //  Возвращение сети значения функции активации нейрона последнего слоя
}                                                                           ////////////////////////////////////////////////////////////////////////////

////
//
//  Обучающая выборка
//
////////////
function cArr(x, y) {
    var number = 0;
    for (var i = 1; i <= x; i++) {
        for (var j = 1; j <= y; j++) {
            Ts.push([]);
            Ts[number].push(i);
            Ts[number].push(j);
            Ts[number].push((i <= (Xn / P) ? left : right));
            number++;
        }
    }
}

function teach(m, n = 0.1)    // Процедура для обучения многослойного персептрона
{
    var b = [];                            //Инициализация массива ошибок
    for (var epoch = 0; epoch < m; epoch++) //Эпохи обучения
    {
        ///////
        //    Обратное распространение ошибки
        //////////////////
        Ts.forEach((exampl, index) => //Перебор всей обучающей выборки где example - обучающий пример, а index - порядковый номер примера в обучающей выборке
        {
            b = [];  //Обнуление массива ошибок
            var value = Ts[Math.round(rnd(0, 199))]; //Выбираем случайный пример из обучающей выборки
            N.forEach((v, i) => b.push([])); //Создаем новые пустые слои для ошибок нейронов
            for (var l = (L - 1); l >= 0; --l) //Обратное распространение
            {
                for (var k = 0; k < N[l]; k++) //Перебираем нейроны
                {
                    var y = neuron(value.slice(0, 2)); //Получаем ответ нейрона
                    if (l == (L - 1)) //Для последнего слоя
                    {
                        b[l].push((y - value[2]) * (y * (1 - y))); //Расчитываем ошибку 
                    }
                    else {
                        var summError = 0;  //Обнуление сумматора
                        b[l + 1].forEach((error, Neuron) =>  //Перебор ошибок нейронов последующего слоя
                        {
                            summError += error * w[l + 1][Neuron][k]; //Суммируем ошибки нейроно последующего слоя
                        }
                        );
                        b[l].push(summError * (y * (1 - y))); //Записываем результат ошибки
                    }
                }
            }
            ////////
            // Корректировка весов
            //////////////////////////
            out.forEach(        // Проходимся по всем слоям сети
                (layer, l) =>     //layer - содержит все нейроны в слое, а l - номер слоя
                {
                    w[l].forEach(   //Проходимся по всем нейронам в слое
                        (k, j) =>       //k - массив весовых коэффициентов нейрона, а j - номер нейрона
                        {
                            k.forEach(      //Перебираем весовые коэффициенты нейрона
                                (weight, i) =>   //weight - весовой коэффициент, а i номер весового коэффициента
                                {
                                    let fp = out[l][j] * (1 - out[l][j]);                             //Производная функции активации
                                    w[l][j][i] += -n * fp * b[l][j] * (l == 0 ? value[i] : out[l - 1][i]);  //Корректировка весового коэффициента
                                }
                            );
                        }
                    )
                }
            );
        }
        );
    }
    Er.push([iteration, E()]);                   //Добавление значения ошибки сети в массив по конкретной итерации обучения
    iteration++;                                //Увеличиваем номер интерации обучения на еденицу
    google.charts.setOnLoadCallback(drawChart); //Рендерим график ошибки сети
}

function E() {
    var s = 0;
    Ts.forEach((value, index) => {
        s += (neuron(value.slice(0, 2)) - value[2]) ** 2;
    }
    );
    return 1 / Ts.length * s;
}

////////////////
//
//		График ошибки сети
//
//////////////////////////////////////////////////
google.charts.load('current', { 'packages': ['corechart'] });  //Подключаем график из API google
function drawChart()  //Процедура для прорисовки графика
{
    var data = google.visualization.arrayToDataTable(Er); //Передаем массив для прорисовки
    var options = {             //  Конфигурация
        title: 'Ошибка сети',       //  отображения
        curveType: 'function',        //  легенд
        legend: { position: 'bottom' }  //  на графике
    };
    var chart = new google.visualization.LineChart(document.querySelector('.error-network')); // Прикрепляем график к нашему блоку div
    chart.draw(data, options); //Рисуем график
}

function answer(o, x, y)      //Процедура маркирующая ячейки соответствующим цветом в зависимости от ответа
{
    var Table = document.getElementsByClassName('row')[y - 1].getElementsByClassName('row-cell')[x - 1]; //Получаем ячейку
    if (o <= 0.5)          // Если ответ сети меньше чем 0.5
    {
        Table.classList.toggle('row-cell__blue'); //Красим ячейку в синий цвет если ответ подходит под левую сторону
    }
    else {
        Table.classList.toggle('row-cell__green'); //Красим ячейку в зеленый цвет если ответ подходит под правую сторону
    }
}


window.onload = () => { initialization(); cArr(Xn, Yn); } //  Проведение инициализации и наполнения массива обучающей выборки при загрузке страницы